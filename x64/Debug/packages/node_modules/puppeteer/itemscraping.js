const puppeteer = require('puppeteer-extra');
const StealthPlugin = require('puppeteer-extra-plugin-stealth');
puppeteer.use(StealthPlugin());

(async () => {
  const targetUrl = process.argv[2];
  const linkSelector = process.argv[3];
  const variationSelector = process.argv[4]
  const titleSelector = process.argv[5];
  const storeAreaSelector = process.argv[6]
  const storeSelector = process.argv[7]
  const priceSelector = process.argv[8];
  const storeItemsSelector = process.argv[9];
  const storeInfoSelector = process.argv[10];
  const storeEmailSelector = process.argv[11];

  if (!targetUrl || !linkSelector || !variationSelector || !titleSelector || !storeAreaSelector || !storeSelector || !priceSelector || !storeItemsSelector || !storeInfoSelector || !storeEmailSelector) {
    console.error('Usage: node combined.js <URL> <linkSelector> <variationSelector> <titleSelector> <storeAreaSelector> <storeSelector> <priceSelector> <storeItemsSelector> <storeInfoSelector> <storeEmailSelector>');
    process.exit(1);
  }

  const browser = await puppeteer.launch({ headless: false });
  const page = await browser.newPage();

  await page.setExtraHTTPHeaders({ 'Accept-Language': 'en-US,en;q=0.9' });
  await page.setUserAgent( 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36' );

  await page.goto(targetUrl, { waitUntil: 'networkidle2' });
  await page.waitForSelector(linkSelector);
  
  const itemUrls = await page.evaluate((sel) => {
	  return Array.from(document.querySelectorAll(sel))
	  .map(el => el.href || el.getAttribute('href'))
	  .filter(Boolean)
	  .map(link => link.startsWith('https') ? link : new URL(link, location.origin).href);
  }, linkSelector);
  
  const results = [];
  
  const getEmailFromShop = async(shopUrl, browser) => {
	  const shopPage = await browser.newPage();
	  try {
		  await shopPage.goto(shopUrl, { waitUntil: 'networkidle0', timeout: 15000 });
		  await shopPage.waitForSelector(storeInfoSelector, { timeout: 5000 });
		  const infoLink = await shopPage.$eval(storeInfoSelector, el => el.href);
		  
		  if (!infoLink) return 'N/A';
		  
		  await shopPage.goto(infoLink, { waitUntil: 'networkidle0', timeout: 15000});
		  
		  //scroll for lazy loading
		  
		  await shopPage.evaluate(() => window.scrollTo(0, document.body.scrollHeight));
		  
		  const email = await shopPage.$eval(storeEmailSelector, el => el.textContent.trim().replace(/\u00A0/g, ' ').replace(/\s+/g, ' '));
		  
		  return email || 'N/A';
	  } catch (err) {
		  console.warn(`Failed to grab email ${shopUrl}: ${err.message}`);
		  return 'N/A';
	  } finally {
		  await shopPage.close();
	  }
  };
		  
  for (const url of itemUrls) {
	  const itemPage = await browser.newPage();
	  try {
		  await itemPage.goto(url, { waitUntil: 'networkidle0', timeout: 20000 });
		  
		  let variationLinks = [];
		  
		  try {
			  await itemPage.waitForSelector(variationSelector + ' a', { timeout: 2000 });
			  variationLinks = await itemPage.$$eval(variationSelector + ' a', links =>
				links.map(link => link.href)
			  );
		  } catch (err) {
			  console.warn(`No variations found on ${url}`);
		  }
		  
		  const normalizeUrl = (rawUrl) => {
			  try {
				  const u = new URL(rawUrl, url);
				  u.search = '';
				  return u.href;
			  } catch {
				  return rawUrl;
			  }
		  };
		  
		  variationLinks = Array.from( new Set([normalizeUrl(url), ...variationLinks.map(normalizeUrl)]));

		  		  
		  const itemResults = [];
		  
		  for (const vUrl of variationLinks) {
			const variationPage = await browser.newPage();
			try {
				await variationPage.goto(vUrl, { waitUntil: 'networkidle0', timeout: 20000 });
				
				await variationPage.evaluate(async () => {
					// Scroll for lazy loading
					await new Promise(resolve => {
						let totalHeight = 0;
						const distance = 300;
						const interval = 30;
						
						const timer = setInterval(() => {
							window.scrollBy(0, distance);
							totalHeight += distance;
	
							if (totalHeight >= document.body.scrollHeight) {
								clearInterval(timer);
								resolve();
							}
						}, interval);
					});
				});
				
				await variationPage.waitForSelector(titleSelector, { timeout: 10000 });
				await variationPage.waitForSelector(priceSelector, { timeout: 10000 });
				await variationPage.waitForSelector(storeAreaSelector, { timeout: 10000 });
				await variationPage.waitForSelector(storeSelector, { timeout: 10000 });
				await variationPage.waitForSelector(storeItemsSelector, { timeout: 10000 });
				
				const data = await variationPage.evaluate((titleSel, storeAreaSel, storeNameSel, storePriceSel, storeItemsSel) => {
					const titleEl = document.querySelector(titleSel);			  
					const title = titleEl && titleEl.childNodes.length ? titleEl.childNodes[0].textContent.trim().replace(/\u00A0/g, ' ') : 'N/A';
			  
					const stores = Array.from(document.querySelectorAll(storeAreaSel))
					.filter(el => !el.classList.contains('featured-merchant-card')) //skipping skroutz's featured merchants
					.map(storeEl => {
						const storeNameEl = storeEl.querySelector(storeNameSel);
						const priceEl = storeEl.querySelector(storePriceSel);
						const linkEl = storeEl.querySelector(storeItemsSel);
						
						const storeName = storeNameEl ? storeNameEl.textContent.trim().replace(/\u00A0/g, ' ') : 'Unknown';
						const shopLink = linkEl?.href || null;
						
						let price = 'N/A';
						if(priceEl) {
						const span = priceEl.querySelector('span');
						if (span && span.nextSibling && span.nextSibling.nodeType === Node.TEXT_NODE) {
							const match = span.nextSibling.textContent.match(/[\d,.]+/);
							price = match ? match[0].replace(',', '.') : 'N/A';
						} else {
							const match = priceEl.textContent.match(/[\d,.]+/);
							price =  match ? match[0].replace(',', '.') : 'N/A';
							}
						}
						return{ name: storeName, price, shopLink };
					});
			
					return { title, stores };
				}, titleSelector, storeAreaSelector, storeSelector, priceSelector, storeItemsSelector);
		
				for (const store of data.stores) {
					store.email = store.shopLink ? await getEmailFromShop(store.shopLink, browser) : 'N/A';
				}
				
				itemResults.push({...data});
			} catch (err) {
				console.warn(`Failed to scrape variation ${vUrl}: ${err.message}`);
			} finally {
				await variationPage.close();
			}
		}
			results.push({ product: url,  variations: itemResults });
	  } catch (err) {
		  console.warn(`Failed to scrape product ${url}: ${err.message}`);
	  } finally {
		  await itemPage.close();
	  }
  }
  
  console.log(JSON.stringify(results, null, 2));

  await browser.close();
})();

/*
await page.waitForSelector(titleSelector);
  await page.waitForSelector(priceSelector);

  const result = await page.evaluate((titleSel, priceSel) => {
    const titles = Array.from(document.querySelectorAll(titleSel)).map(el =>
      el.textContent.trim().replace(/\u00A0/g, ' ')
    );

    const prices = Array.from(document.querySelectorAll(priceSel)).map(el => {
      const span = el.querySelector('span');
      if (span && span.nextSibling && span.nextSibling.nodeType === Node.TEXT_NODE) {
        const match = span.nextSibling.textContent.match(/[\d,.]+/);
        return match ? match[0].replace(',', '.') : 'N/A';
      } else {
        const match = el.textContent.match(/[\d,.]+/);
        return match ? match[0].replace(',', '.') : 'N/A';
      }
    });

    return { items: titles, prices };
  }, titleSelector, priceSelector);
  */